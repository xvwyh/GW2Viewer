module;
#include "Utils/Scan.h";

export module GW2Viewer.Data.Content:TypeInfo;
import GW2Viewer.Common;
import GW2Viewer.Common.GUID;
import GW2Viewer.Common.JSON;
import GW2Viewer.Content;
import GW2Viewer.Utils.Format;
import GW2Viewer.Utils.Scan;
import std;
import <cassert>;
import <boost/container/small_vector.hpp>;
#include "Macros.h"

export namespace GW2Viewer::Data::Content
{
struct ContentObject;
struct ContentTypeInfo;

struct TypeInfo
{
    struct Condition
    {
        using ValueType = int64;
        enum class Comparisons
        {
            Equal,
            NotEqual,
            Less,
            LessOrEqual,
            Greater,
            GreaterOrEqual,
        };
        static constexpr char const* IMGUI_COMPARISONS = "==\0!=\0<\0<=\0>\0>=\0";

        std::string Field;
        Comparisons Comparison = Comparisons::Equal;
        ValueType Value = 0;

        NLOHMANN_DEFINE_TYPE_ORDERED_INTRUSIVE_WITH_DEFAULT(Condition
            , Field
            , Comparison
            , Value
        )

        [[nodiscard]] bool Test(ValueType value) const
        {
            switch (Comparison)
            {
                using enum Comparisons;
                case Equal:          return value == Value;
                case NotEqual:       return value != Value;
                case Less:           return value <  Value;
                case LessOrEqual:    return value <= Value;
                case Greater:        return value >  Value;
                case GreaterOrEqual: return value >= Value;
                default: assert("Unhandled TypeInfo::Condition::Comparisons"); return false;
            }
        }

        bool operator==(Condition const&) const = default;
    };
    struct Enum
    {
        using UnderlyingType = int64;
        using FlagsUnderlyingType = std::make_unsigned_t<UnderlyingType>;
        static constexpr char const* FORMAT = "%lli";
        static constexpr char const* FLAGS_FORMAT = "%llX";

        std::string Name;
        bool Flags = false;
        std::map<int64, std::string> Values;

        NLOHMANN_DEFINE_TYPE_ORDERED_INTRUSIVE_WITH_DEFAULT_OMITTED(Enum
            , Name
            , Flags
            , Values
        )

        bool operator==(Enum const&) const = default;

        char const* GetFormat() const { return Flags ? FLAGS_FORMAT : FORMAT; }
    };
    struct Context;
    struct Symbol;
    struct SymbolType
    {
        char const* Name;

        SymbolType(char const* name) : Name(name) { }
        virtual ~SymbolType() = default;

        [[nodiscard]] virtual bool IsVisible() const { return true; }
        [[nodiscard]] virtual std::strong_ordering CompareDataForSearch(byte const* dataA, byte const* dataB) const;
        [[nodiscard]] virtual std::optional<Condition::ValueType> GetValueForCondition(Context const& context) const = 0;
        [[nodiscard]] virtual std::string GetDisplayText(Context const& context) const = 0;
        [[nodiscard]] virtual std::optional<uint32> GetIcon(Context const& context) const { return { }; };
        [[nodiscard]] virtual std::optional<ContentObject const*> GetMap(Context const& context) const { return { }; };
        [[nodiscard]] virtual bool IsArray() const { return false; }
        [[nodiscard]] virtual std::optional<uint32> GetArrayCount(Context const& context) const { return { }; }
        [[nodiscard]] virtual std::optional<byte const*> GetPointer(Context const& context) const { return { }; }
        [[nodiscard]] virtual bool IsContent() const { return false; }
        [[nodiscard]] virtual std::optional<ContentObject const*> GetContent(Context const& context) const { return { }; }
        [[nodiscard]] virtual bool IsInline() const { return true; }
        [[nodiscard]] virtual uint32 Alignment() const { return 1; }
        [[nodiscard]] virtual uint32 Size() const = 0;
        [[nodiscard]] virtual ordered_json Export(Context const& context) const = 0;
        virtual void Draw(Context const& context) const = 0;
    };
    using SymbolMap = std::multimap<uint32, Symbol>;
    struct StructLayout
    {
        SymbolMap Symbols;
        bool Autogenerated = false; // Don't serialize

        void Initialize(ContentTypeInfo const& typeInfo);

        friend void to_json(ordered_json& json, StructLayout const& self);
        friend void from_json(ordered_json const& json, StructLayout& self);

        bool operator==(StructLayout const& other) const { return Symbols == other.Symbols; }
    };
    struct LayoutFrame
    {
        ContentObject const* Content;
        StructLayout* Layout;
        std::optional<std::string> Path;
        uint32 DataStart = 0;
        uint32 ObjectStart = 0;
        uint32 ObjectStackDepth = 0;
        bool IsFolded = false;
    };
    using LayoutStack = std::stack<LayoutFrame, boost::container::small_vector<LayoutFrame, 10>>;
    struct Symbol
    {
        std::optional<Condition> Condition;
        std::string Name;
        std::string Type;
        std::optional<Enum> Enum;
        uint32 Alignment = 0;
        bool Table = false;
        uint32 ElementSize = 1;
        std::string ElementTypeName;
        StructLayout ElementLayout;

        TypeInfo::Enum* GetEnum();
        TypeInfo::Enum const* GetEnum() const { return const_cast<Symbol*>(this)->GetEnum(); }
        StructLayout& GetElementLayout();
        StructLayout const& GetElementLayout() const { return const_cast<Symbol*>(this)->GetElementLayout(); }

        NLOHMANN_DEFINE_TYPE_ORDERED_INTRUSIVE_WITH_DEFAULT_OMITTED(Symbol
            , Condition
            , Name
            , Type
            , Enum
            , Alignment
            , Table
            , ElementSize
            , ElementTypeName
            , ElementLayout
        )

        bool Autogenerated = false;
        bool Folded = false;
        std::optional<bool> EnumShared;
        std::optional<bool> ElementTypeShared;

        enum class DrawType
        {
            Inline,
            TableCountColumns,
            TableHeader,
            TableRow,
        };

        [[nodiscard]] std::optional<Condition::ValueType> GetValueForCondition(ContentObject const& content, LayoutStack const& layoutStack);
        [[nodiscard]] bool TestCondition(ContentObject const& content, LayoutStack const& layoutStack);
        struct TraversalInfo
        {
            SymbolType const* Type;
            uint32 Size;
            std::optional<byte const*> Start;
            std::optional<uint32> ArrayCount;
            bool ForceInline = false;

            [[nodiscard]] operator bool() const { return Start && *Start && (!ArrayCount || *ArrayCount && *ArrayCount <= 20000) && (ForceInline || Type->IsInline()); }
        };
        [[nodiscard]] TraversalInfo GetTraversalInfo(Context const& context, bool forceInline = false) const
        {
            auto const type = GetType();
            return { type, ElementSize, type->GetPointer(context), type->GetArrayCount(context), forceInline };
        }
        void DrawOptions(TypeInfo& typeInfo, LayoutStack const& layoutStack, std::string_view parentPath, bool create, std::string const& placeholderName);
        void Draw(byte const* data, DrawType draw, ContentObject const& content);
        [[nodiscard]] uint32 Size() const;
        [[nodiscard]] uint32 AlignedSize() const;
        [[nodiscard]] SymbolType const* GetType() const;
        [[nodiscard]] std::string GetFullPath(std::string_view parentPath) const
        {
            if (!parentPath.empty())
                return std::format("{}->{}", parentPath, Name);
            return Name;
        }

        bool operator==(Symbol const&) const = default;
    };
    struct Context
    {
        template<typename T> decltype(auto) Data() const { return *(T const*)m_data; }
        ContentObject const& Content;
        Symbol& Symbol;
        Symbol::DrawType Draw;

        template<typename T> Context(T const* data, ContentObject const& content, struct Symbol& symbol, Symbol::DrawType draw = { }) : Content(content), Symbol(symbol), Draw(draw), m_data((byte const*)data) { }
        template<typename T> Context(T const* data, Context const& source) : Context((byte const*)data, source.Content, source.Symbol, source.Draw) { }

    private:
        byte const* m_data;
    };

    std::string Name;
    GW2Viewer::Content::EContentTypes ContentType { };
    StructLayout Layout;
    std::string DisplayFormat;
    std::vector<std::string> NameFields;
    std::vector<std::string> IconFields;
    std::vector<std::string> MapFields;
    byte DataLinkType = 0;
    std::string Notes;
    bool Favorite = false;
    std::set<GUID> Examples; // In case content types get shifted when new types are added in the middle, auto-repair NYI

    NLOHMANN_DEFINE_TYPE_ORDERED_INTRUSIVE_WITH_DEFAULT_OMITTED(TypeInfo
        , Name
        , ContentType
        , Layout
        , DisplayFormat
        , NameFields
        , IconFields
        , MapFields
        , DataLinkType
        , Notes
        , Favorite
        , Examples
    )

    void Initialize(ContentTypeInfo const& typeInfo);
};

}
